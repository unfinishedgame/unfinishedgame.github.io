<!DOCTYPE html>
<html>
    <head>
        <title>My Website</title>
        <style>
            body {
                background-color: white;
                overflow: hidden;
            }
            canvas {
                z-index: -1;
                margin: 0px;
                position: absolute;
            }
            .tiny {
                font-size: x-small;
            }
        </style>
    </head>
    <body>
        <div id="loading-explanation">
            <h1>Click a button to start loading</h1>
            <p class="tiny">i need an audiocontext to process the file i fetched from the server and it requires user interaction to use one so just click</p>
            <p class="tiny">if there's a workaround for this please tell me</p>
            <button onclick="(function() {pageMuted = true; beginLoad()})()">Click this to mute the page and start</button>
            <button onclick="beginLoad()">Click this to start</button>
        </div>
        
        <canvas id="canvas"></canvas>
        <script>
            let pageMuted = false
            class LoadedAudio {
                constructor(buffer) {
                    this.buffer = buffer
                    this._played = false
                }
                play() {
                    if (!pageMuted) {
                        const src = audioCtx.createBufferSource()
                        src.buffer = this.buffer
                        src.connect(audioCtx.destination)
                        src.start()
                    }
                }
                playOnce() {
                    if (this._played) return
                    else {
                        this.play()
                        this._played = true
                    }
                }
                reset() {
                    this._played = false
                }
            }
            class CustomMouseEvent {
                static _awaitingClick = []
                static requestClick(callback, id, hover) {
                    let duplicate = false
                    for (let i in CustomMouseEvent._awaitingClick) {
                        if (CustomMouseEvent._awaitingClick[i].id == id) {
                            duplicate = true
                            break
                        }
                    }
                    if (!duplicate) CustomMouseEvent._awaitingClick.push({callback: callback, id: id, hover: hover})
                }
                constructor(event, type) {
                    for (let i in event) {
                        this[i] = event[i]
                    }
                    this.type = type
                    if (this.type == 'click' && CustomMouseEvent._awaitingClick.length > 0 && (!CustomMouseEvent._awaitingClick[0].hover || CustomMouseEvent._awaitingClick[0].hover.checkHovering())) {
                        CustomMouseEvent._awaitingClick.shift().callback()
                    }
                }
            }
            const audioCtx = new AudioContext()

            let begunLoading = false
            const assetDirs = {
                sounds: {
                    startup: 'startup.mp3'
                }
            }
            let assets = {}

            let mouse
            addEventListener('mousemove', function(event) {
                mouse = new CustomMouseEvent(event, 'move')
            })
            addEventListener('click', function(event) {
                mouse = new CustomMouseEvent(event, 'click')
            })
            
            class HoverableText {
                constructor(metric, x, y, canvas, centered) {
                    this.metric = metric
                    this.x = x
                    this.y = y
                    this.canvas = canvas
                    this.centered = centered
                }
                checkHovering() {
                    const up = this.canvas.style.top ? Number(this.canvas.style.top.substring(0, this.canvas.style.top.length - 2)) : 0
                    const left = this.canvas.style.left ? Number(this.canvas.style.left.substring(0, this.canvas.style.left.length - 2)) : 0
                    
                    const textX = this.x - (this.centered ? this.metric.actualBoundingBoxLeft : 0)
                    const textY = this.y - (this.centered ? this.metric.actualBoundingBoxAscent : 0)
                    const startWidth = this.metric.actualBoundingBoxLeft + this.metric.actualBoundingBoxRight
                    const startHeight = this.metric.actualBoundingBoxAscent + this.metric.actualBoundingBoxDescent
                    return mouse && mouse.pageX - left > textX && mouse.pageY - up > textY && mouse.pageX - left < startWidth + textX && mouse.pageY - up < startHeight + textY
                }
            }
            
            function beginLoad() {
                if (!begunLoading) {
                    load()
                    .then(startup)
                    .catch(error => alert("something went wrong. please reload. if this is your fifth time reloading, report a bug. this was the error: \n\n" + error.message + "\n" + error.stack))
                }
            }
            async function load() {
                begunLoading = true
                document.querySelector("#loading-explanation").remove()
                for (let i in assetDirs) {
                    for (let j in assetDirs[i]) {
                        let convert
                        if (i == 'sounds') {
                            convert = async function(file) {
                                const buffer = await audioCtx.decodeAudioData(await file.arrayBuffer())
                                
                                return new LoadedAudio(buffer)
                            }
                        }
                        if (!assets[i]) assets[i] = {}
                        assets[i][j] = await convert(await fetch('/assets/' + i + '/' + assetDirs[i][j]))
                    }
                }
            }
            const canvas = document.querySelector('#canvas')
            const ctx = canvas.getContext('2d')
            let timer = 0
            let lastFrame, currentFrame, delta

            let w, h
            function resizeCanvas() {
                if (innerHeight * 16 / 9 <= innerWidth) {
                    canvas.height = innerHeight
                    canvas.width = innerHeight * 16 / 9
                    canvas.style.top = '0px';
                    canvas.style.left = (innerWidth - canvas.width) / 2 + 'px'
                } else {
                    canvas.width = innerWidth
                    canvas.height = innerWidth * 9 / 16
                    canvas.style.left = '0px';
                    canvas.style.top = (innerHeight - canvas.height) / 2 + 'px'
                }
                w = canvas.width
                h = canvas.height
            }
            resizeCanvas()

            addEventListener('resize', resizeCanvas)
            function updateCanvas() {
                try {
                    currentFrame = Date.now()
                    delta = currentFrame - lastFrame

                    ctx.clearRect(0, 0, w, h)
                    timer += delta
                    update()
                    draw()

                    requestAnimationFrame(updateCanvas)
                    lastFrame = Date.now()
                } catch (e) {
                    alert("OH NO ERROR AHHHHHHHHHHHHHHHHHHHHH\n" + e.message + "\n" + e.stack)
                    alert("(just reload the page and report the bug)")
                }
            }
            let update, draw
            function startup() {
                update = function() {}
                
                draw = function() {
                    ctx.fillStyle = 'rgb(200, 200, 200)'
                    ctx.fillRect(0, 0, w, h)
                    
                    if (timer > 700) {
                        const col = Math.min(200, (timer - 700) / 10)
                        ctx.strokeStyle = `rgb(${col}, ${col}, ${col})`
                        ctx.strokeRect(w / 3, h / 20 * 7, w / 3, h / 3)

                        assets.sounds.startup.playOnce()
                    }
                    ctx.font = w / 16 + 'px monospace'
                    ctx.textAlign = 'center'
                    ctx.fillStyle = 'black'
                    ctx.fillText("Website".substring(0, (timer - 1000) / 100), w / 2, h / 2)
                    
                    ctx.font = w / 32 + 'px monospace'
                    ctx.fillText("By me".substring(0, (timer - 2000) / 100), w / 2, h / 5 * 3)
                    
                    if (timer > 3000) {
                        ctx.font = w / 16 + 'px monospace'
                        const start = new HoverableText(ctx.measureText("Open"), w / 2, h / 4 * 3, canvas, true)

                        CustomMouseEvent.requestClick(mainMenu, "mainMenu", start)
                        if (start.checkHovering()) {
                            ctx.fillStyle = 'darkgrey'
                        } else ctx.fillStyle = 'grey'
                        
                        ctx.fillText("Open", w / 2, h / 4 * 3)
                    }
                }
                lastFrame = Date.now()
                updateCanvas()
            }
            function mainMenu() {
                alert("congratulations! you made it to the main menu! (work in progress)")
            }
        </script>
    </body>
</html>